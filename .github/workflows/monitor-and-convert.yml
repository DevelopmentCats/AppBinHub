name: Monitor and Convert

run-name: "${{ github.event_name == 'schedule' && '‚è∞ Scheduled run' || github.event_name == 'workflow_dispatch' && 'üîß Manual run' || 'üì¶ Auto-triggered' }}"

on:
  schedule:
    # Run twice daily at 8 AM and 8 PM UTC
    - cron: '0 8,20 * * *'
  workflow_dispatch:
    inputs:
      check_frequency:
        description: 'Check frequency'
        required: false
        default: 'daily'
        type: choice
        options:
        - daily
        - weekly
  push:
    branches: [ main ]
    paths: 
      - 'scripts/**'
      - '.github/workflows/**'

# Only ONE run at a time across ALL triggers (schedule, push, workflow_dispatch)
# cancel-in-progress: true means new runs cancel old ones
concurrency:
  group: appbinhub-monitor-convert
  cancel-in-progress: true

jobs:
  monitor:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      actions: write  # Needed to trigger other workflows
    
    outputs:
      apps_to_convert: ${{ steps.check_apps.outputs.apps_to_convert }}
      conversion_needed: ${{ steps.check_apps.outputs.conversion_needed }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        cd scripts
        pip install -r requirements.txt
    
    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action Bot"
    
    - name: Check for pending applications
      id: check_updates
      run: |
        cd scripts
        
        if [ -f ../website/data/applications.json ]; then
          pending_count=$(python3 -c 'import json; data=json.load(open("../website/data/applications.json")); print(len([app for app in data.get("applications", []) if app.get("conversion_status") == "pending"]))')
          echo "pending_apps=$pending_count" >> $GITHUB_OUTPUT
          
          last_update=$(python3 -c 'import json; from datetime import datetime, timezone; from dateutil import parser; data=json.load(open("../website/data/applications.json")); last_updated=data.get("metadata", {}).get("last_updated", ""); print(int((datetime.now(timezone.utc) - parser.parse(last_updated)).total_seconds() / 3600) if last_updated else 999)' 2>/dev/null || echo "999")
          echo "hours_since_update=$last_update" >> $GITHUB_OUTPUT
        else
          echo "pending_apps=0" >> $GITHUB_OUTPUT
          echo "hours_since_update=999" >> $GITHUB_OUTPUT
        fi
    
    - name: Monitor AppImage sources
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cd scripts
        python monitor.py
      continue-on-error: true
    
    - name: Check for new applications
      id: check_new_apps
      run: |
        if [ -n "$(git status --porcelain website/data/applications.json)" ]; then
          echo "new_apps_found=true" >> $GITHUB_OUTPUT
        else
          echo "new_apps_found=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Analyze conversion queue
      id: check_apps
      run: |
        cd scripts
        
        apps_json=$(python3 list_pending_apps.py)
        echo "apps_to_convert=$apps_json" >> $GITHUB_OUTPUT
        
        if echo "$apps_json" | jq -e '. | length > 0' > /dev/null; then
          echo "conversion_needed=true" >> $GITHUB_OUTPUT
        else
          echo "conversion_needed=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Commit new applications
      run: |
        if [ -n "$(git status --porcelain)" ]; then
          git add .
          git commit -m "Monitor: Found new AppImages - $(date -u '+%Y-%m-%d %H:%M UTC')"
          git push
        else
          echo "No changes to commit"
        fi
  
  convert:
    if: needs.monitor.outputs.conversion_needed == 'true'
    needs: monitor
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/developmentcats/appbinhub-converter:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    timeout-minutes: 60
    
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        ref: main
    
    - name: Configure Git for container
      run: |
        git config --global --add safe.directory /__w/AppBinHub/AppBinHub
    
    - name: Pull latest changes from monitor
      run: |
        git pull origin main
    
    - name: Install Python dependencies
      run: |
        cd scripts
        pip install --break-system-packages -r requirements.txt
    
    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action Bot"
    
    - name: Convert all architectures
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cd scripts
        
        echo "üîÑ Starting cross-compilation conversion..."
        echo "GitHub Runner: ${{ runner.os }} ${{ runner.arch }}"
        echo "Available disk space:"
        df -h
        
        # Convert all pending apps (all architectures in one pass)
        python3 -c "
        import sys
        import json
        import time
        sys.path.append('.')
        from converter import ModernAppImageConverter
        
        print('Converting all pending applications...')
        print(f'Start time: {time.strftime(\"%Y-%m-%d %H:%M:%S UTC\", time.gmtime())}')
        
        try:
            converter = ModernAppImageConverter()
        except Exception as e:
            print(f'Error initializing converter: {e}')
            raise
        
        # Filter only pending apps
        pending_apps = [app for app in converter.data['applications'] if app.get('conversion_status') == 'pending']
        print(f'Found {len(pending_apps)} pending apps to convert')
        
        if len(pending_apps) == 0:
            print('No pending apps to convert')
            sys.exit(0)
        
        # Group by architecture for reporting
        by_arch = {}
        for app in pending_apps:
            arch = app.get('architecture', 'unknown')
            by_arch[arch] = by_arch.get(arch, 0) + 1
        
        for arch, count in by_arch.items():
            print(f'  - {arch}: {count} apps')
        
        converter.convert_pending_applications()
        
        print(f'Conversion completed at: {time.strftime(\"%Y-%m-%d %H:%M:%S UTC\", time.gmtime())}')
        "
      continue-on-error: true
    
    - name: Check conversion results
      id: check_results
      run: |
        # Count converted apps
        converted_count=$(python3 -c "
        import json
        with open('website/data/applications.json', 'r') as f:
            data = json.load(f)
        
        converted = sum(1 for app in data['applications'] if app.get('conversion_status') == 'completed')
        print(converted)
        ")
        
        echo "converted_count=$converted_count" >> $GITHUB_OUTPUT
        
        # Check if packages were created
        if [ -d "website/packages" ] && [ "$(find website/packages -type f \( -name '*.deb' -o -name '*.rpm' -o -name '*.tar.gz' \) 2>/dev/null | wc -l)" -gt 0 ]; then
          echo "packages_created=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Packages created:"
          find website/packages -type f \( -name '*.deb' -o -name '*.rpm' -o -name '*.tar.gz' \) | while read f; do
            size=$(du -h "$f" | cut -f1)
            echo "  - $(basename $f) ($size)"
          done
        else
          echo "packages_created=false" >> $GITHUB_OUTPUT
          echo "‚ùå No packages created"
        fi
        
        # Check if JSON changed
        if [ -n "$(git status --porcelain website/data/applications.json)" ]; then
          echo "json_changed=true" >> $GITHUB_OUTPUT
          echo "‚úÖ JSON updated"
        else
          echo "json_changed=false" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è  JSON not changed"
        fi
    
    - name: Upload packages to GitHub Releases
      if: steps.check_results.outputs.packages_created == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python3 << 'PYEOF'
        import json
        import os
        import subprocess
        from pathlib import Path
        
        # Load JSON to find converted apps
        with open('website/data/applications.json', 'r') as f:
            data = json.load(f)
        
        # Group converted apps by base_id/version
        releases = {}
        for app in data['applications']:
            if app.get('conversion_status') == 'completed':
                base_id = app.get('base_id', app['id'])
                version = app['version']
                key = (base_id, version)
                
                if key not in releases:
                    releases[key] = {
                        'base_id': base_id,
                        'version': version,
                        'name': app['name'].split(' (')[0],  # Remove architecture suffix
                        'apps': []
                    }
                releases[key]['apps'].append(app)
        
        repo = os.environ['GITHUB_REPOSITORY']
        
        # Create releases and upload packages
        for (base_id, version), release_info in releases.items():
            release_tag = f"{base_id}-v{version}"
            name = release_info['name']
            
            print(f"\nüì¶ Processing release: {release_tag}")
            
            # Check if release exists
            result = subprocess.run(['gh', 'release', 'view', release_tag], 
                                  capture_output=True, text=True)
            
            if result.returncode != 0:
                # Create release
                print(f"Creating release {release_tag}...")
                notes = f"Converted packages for {name} version {version}\n\n## Available Packages\n- DEB (Debian/Ubuntu)\n- RPM (Fedora/RHEL)\n- TAR.GZ (Universal)\n\nAutomatically converted from AppImage by AppBinHub."
                subprocess.run([
                    'gh', 'release', 'create', release_tag,
                    '--title', f"{name} v{version}",
                    '--notes', notes
                ], check=True)
            else:
                print(f"Release {release_tag} already exists")
            
            # Find and upload packages
            package_dir = Path(f'website/packages/{base_id}/{version}')
            if package_dir.exists():
                packages = list(package_dir.glob('*.deb')) + \
                          list(package_dir.glob('*.rpm')) + \
                          list(package_dir.glob('*.tar.gz'))
                
                for pkg in packages:
                    print(f"Uploading: {pkg.name}")
                    subprocess.run([
                        'gh', 'release', 'upload', release_tag, str(pkg), '--clobber'
                    ], check=True)
            
            # Update JSON with release URLs
            for app in release_info['apps']:
                arch = app['architecture']
                if 'converted_packages' in app:
                    packages = app['converted_packages']
                    
                    # DEB
                    if 'deb' in packages and packages['deb'].get('status') == 'available':
                        deb_arch = 'amd64' if arch == 'x86_64' else 'arm64' if arch == 'aarch64' else 'armhf'
                        filename = f"{base_id}_{version}_{deb_arch}.deb"
                        packages['deb']['url'] = f"https://github.com/{repo}/releases/download/{release_tag}/{filename}"
                    
                    # RPM
                    if 'rpm' in packages and packages['rpm'].get('status') == 'available':
                        filename = f"{base_id}-{version}-1.{arch}.rpm"
                        packages['rpm']['url'] = f"https://github.com/{repo}/releases/download/{release_tag}/{filename}"
                    
                    # TAR.GZ
                    if 'tarball' in packages and packages['tarball'].get('status') == 'available':
                        filename = f"{base_id}-{version}-{arch}.tar.gz"
                        packages['tarball']['url'] = f"https://github.com/{repo}/releases/download/{release_tag}/{filename}"
        
        # Save updated JSON
        with open('website/data/applications.json', 'w') as f:
            json.dump(data, f, indent=2)
            f.write('\n')
        
        print(f"\n‚úÖ Uploaded {len(releases)} releases")
        PYEOF
    
    - name: Clean up temporary files
      run: |
        cd scripts
        rm -f *.log
        
        # Remove package files from workspace (they're now in releases)
        cd ..
        rm -rf website/packages
    
    - name: Commit conversion results
      if: steps.check_results.outputs.json_changed == 'true'
      run: |
        git add website/data/applications.json
        git commit -m "Convert: ${{ steps.check_results.outputs.converted_count }} apps across all architectures - $(date -u '+%Y-%m-%d %H:%M UTC')" || echo "Nothing to commit"
        git push || echo "Nothing to push"
    
    - name: Create summary
      if: always()
      run: |
        echo "## üîÑ Cross-Compilation Conversion Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Total apps converted:** ${{ steps.check_results.outputs.converted_count || '0' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Packages created:** ${{ steps.check_results.outputs.packages_created }}" >> $GITHUB_STEP_SUMMARY
        echo "- **JSON updated:** ${{ steps.check_results.outputs.json_changed }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Tools" >> $GITHUB_STEP_SUMMARY
        echo "- **Mode:** Cross-compilation (all architectures on x86_64 runner)" >> $GITHUB_STEP_SUMMARY
        echo "- **DEB:** $(dpkg-deb --version 2>&1 | head -1 || echo 'not available')" >> $GITHUB_STEP_SUMMARY
        echo "- **RPM:** $(rpmbuild --version 2>&1 | head -1 || echo 'not available')" >> $GITHUB_STEP_SUMMARY

