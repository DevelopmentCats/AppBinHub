name: AppImage Monitoring

on:
  schedule:
    # Run twice per day (morning and evening)
    - cron: '0 8,20 * * *'
  workflow_dispatch:
    # Allow manual triggering with options
    inputs:
      check_frequency:
        description: 'Check frequency (daily/weekly)'
        required: false
        default: 'daily'
        type: choice
        options:
        - daily
        - weekly
  push:
    branches: [ main ]
    paths: 
      - 'scripts/**'
      - '.github/workflows/**'

# Prevent multiple runs from interfering
concurrency:
  group: monitor-workflow
  cancel-in-progress: true

jobs:
  monitor:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      actions: write  # Needed to trigger other workflows
    
    outputs:
      apps_to_convert: ${{ steps.check_apps.outputs.apps_to_convert }}
      conversion_needed: ${{ steps.check_apps.outputs.conversion_needed }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install Python dependencies
      run: |
        cd scripts
        pip install -r requirements.txt
    
    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action Bot"
    
    - name: Check for existing updates
      id: check_updates
      run: |
        cd scripts
        
        # Check if we have pending applications
        if [ -f ../website/data/applications.json ]; then
          pending_count=$(python3 -c 'import json; data=json.load(open("../website/data/applications.json")); print(len([app for app in data.get("applications", []) if app.get("conversion_status") == "pending"]))')
          echo "pending_apps=$pending_count" >> $GITHUB_OUTPUT
          
          # Check last update time (hours since last update)
          last_update=$(python3 -c 'import json; from datetime import datetime, timezone; from dateutil import parser; data=json.load(open("../website/data/applications.json")); last_updated=data.get("metadata", {}).get("last_updated", ""); print(int((datetime.now(timezone.utc) - parser.parse(last_updated)).total_seconds() / 3600) if last_updated else 999)' 2>/dev/null || echo "999")
          echo "hours_since_update=$last_update" >> $GITHUB_OUTPUT
        else
          echo "pending_apps=0" >> $GITHUB_OUTPUT
          echo "hours_since_update=999" >> $GITHUB_OUTPUT
        fi
    
    - name: Run AppImage monitoring
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cd scripts
        python monitor.py
      continue-on-error: true
    
    - name: Check if monitoring found new apps
      id: check_new_apps
      run: |
        if [ -n "$(git status --porcelain website/data/applications.json)" ]; then
          echo "new_apps_found=true" >> $GITHUB_OUTPUT
        else
          echo "new_apps_found=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Analyze applications needing conversion
      id: check_apps
      run: |
        cd scripts
        
        # Get list of pending apps and their architectures
        apps_json=$(python3 list_pending_apps.py)
        echo "apps_to_convert=$apps_json" >> $GITHUB_OUTPUT
        
        # Check if any conversions are needed
        if echo "$apps_json" | jq -e '. | length > 0' > /dev/null; then
          echo "conversion_needed=true" >> $GITHUB_OUTPUT
        else
          echo "conversion_needed=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Commit monitoring changes
      run: |
        if [ -n "$(git status --porcelain)" ]; then
          git add .
          git commit -m "Monitor: Found new AppImages - $(date -u '+%Y-%m-%d %H:%M UTC')"
          git push
        else
          echo "No changes to commit"
        fi
  
  convert:
    if: needs.monitor.outputs.conversion_needed == 'true'
    needs: monitor
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
    
    strategy:
      matrix:
        architecture: ['x86_64', 'aarch64', 'armv7l']
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Filter apps for this architecture
      id: filter_apps
      run: |
        apps='${{ needs.monitor.outputs.apps_to_convert }}'
        filtered_apps=$(echo "$apps" | jq -c "[.[] | select(.architecture == \"${{ matrix.architecture }}\")]")
        echo "apps_for_arch=$filtered_apps" >> $GITHUB_OUTPUT
        
        if echo "$filtered_apps" | jq -e '. | length > 0' > /dev/null; then
          echo "has_apps=true" >> $GITHUB_OUTPUT
        else
          echo "has_apps=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Set up Python
      if: steps.filter_apps.outputs.has_apps == 'true'
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install Python dependencies
      if: steps.filter_apps.outputs.has_apps == 'true'
      run: |
        cd scripts
        pip install -r requirements.txt
    
    - name: Install system dependencies for conversion
      if: steps.filter_apps.outputs.has_apps == 'true'
      run: |
        sudo apt-get update
        
        # Install squashfs-tools for AppImage extraction (provides unsquashfs)
        sudo apt-get install -y squashfs-tools
        
        # Install dpkg-dev for creating .deb packages
        sudo apt-get install -y dpkg-dev
        
        # Install rpm for creating .rpm packages
        sudo apt-get install -y rpm
        
        # Install file utilities
        sudo apt-get install -y file binutils
        
        # Verify installations
        echo "Checking tool availability:"
        echo "âœ“ unsquashfs: $(unsquashfs --help 2>&1 | head -1 || echo 'version check failed but tool may be available')"
        echo "âœ“ dpkg-deb: $(dpkg-deb --version | head -1)"
        if command -v rpmbuild &> /dev/null; then
          echo "âœ“ rpmbuild: $(rpmbuild --version | head -1)"
        else
          echo "âœ— rpmbuild: not available (but rpm is installed for basic functionality)"
        fi
        
        # Ensure unsquashfs is in PATH and executable
        which unsquashfs
        ls -la $(which unsquashfs)
    
    - name: Set up QEMU for cross-architecture (if needed)
      if: steps.filter_apps.outputs.has_apps == 'true' && matrix.architecture != 'x86_64'
      uses: docker/setup-qemu-action@v3
      with:
        platforms: linux/arm64,linux/arm/v7,linux/386
    
    - name: Configure Git
      if: steps.filter_apps.outputs.has_apps == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action Bot (${{ matrix.architecture }})"
    
    - name: Parse and filter applications
      if: steps.filter_apps.outputs.has_apps == 'true'
      id: parse_apps
      env:
        INPUT_APPS: ${{ steps.filter_apps.outputs.apps_for_arch }}
        TARGET_ARCH: ${{ matrix.architecture }}
      run: |
        cd scripts
        
        # Use inline Python to process apps (no temp files)
        apps_to_convert=$(python3 -c "
        import json
        import os
        import sys
        
        # Get data from environment variables
        input_apps = json.loads(os.environ['INPUT_APPS'])
        target_arch = os.environ['TARGET_ARCH']
        
        print(f'Apps to convert for {target_arch}:', file=sys.stderr)
        print(json.dumps(input_apps, indent=2), file=sys.stderr)
        
        # Load current applications data
        with open('../website/data/applications.json', 'r') as f:
            data = json.load(f)
        
        # Filter apps for this architecture and mark them for conversion
        apps_for_conversion = []
        for app in data['applications']:
            for input_app in input_apps:
                if app['id'] == input_app['id'] and app.get('architecture') == target_arch:
                    apps_for_conversion.append(app['id'])
                    break
        
        print(f'Apps to convert: {apps_for_conversion}', file=sys.stderr)
        print(f'Found {len(apps_for_conversion)} apps for {target_arch}', file=sys.stderr)
        
        # Output as JSON for the next step
        print(json.dumps(apps_for_conversion))
        ")
        
        echo "apps_to_convert=$apps_to_convert" >> $GITHUB_OUTPUT
        
        # Check if we have any apps
        if [ "$(echo "$apps_to_convert" | jq '. | length')" -gt 0 ]; then
          echo "Apps to convert: $apps_to_convert"
          echo "proceed=true" >> $GITHUB_OUTPUT
        else
          echo "No apps found for conversion"
          echo "proceed=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Run architecture-specific conversion
      if: steps.parse_apps.outputs.proceed == 'true'
      env:
        APPS_TO_CONVERT: ${{ steps.parse_apps.outputs.apps_to_convert }}
        TARGET_ARCH: ${{ matrix.architecture }}
      run: |
        cd scripts
        
        # Use inline Python for conversion (no temp files)
        python3 -c "
        import sys
        import os
        import json
        sys.path.append('.')
        from converter import ModernAppImageConverter
        
        # Get data from environment variables
        apps_to_convert = json.loads(os.environ['APPS_TO_CONVERT'])
        target_arch = os.environ['TARGET_ARCH']
        
        print(f'Starting conversion for {len(apps_to_convert)} apps on {target_arch}')
        
        # Initialize converter
        converter = ModernAppImageConverter()
        
        # Filter to only convert specified apps
        original_apps = converter.data['applications']
        converter.data['applications'] = [
            app for app in original_apps 
            if app['id'] in apps_to_convert and app.get('conversion_status') == 'pending'
        ]
        
        print(f'Filtered to {len(converter.data[\"applications\"])} pending apps')
        
        # Run conversion
        converter.convert_pending_applications()
        
        # Merge results back
        app_dict = {app['id']: app for app in converter.data['applications']}
        for i, app in enumerate(original_apps):
            if app['id'] in app_dict:
                original_apps[i] = app_dict[app['id']]
        
        converter.data['applications'] = original_apps
        converter.save_application_data()
        "
      continue-on-error: true
    
    - name: Check conversion results
      if: steps.parse_apps.outputs.proceed == 'true'
      id: check_results
      run: |
        cd scripts
        
        # Check how many apps were successfully converted
        converted_count=$(python3 -c "
        import json
        with open('../website/data/applications.json', 'r') as f:
            data = json.load(f)
        
        converted = 0
        for app in data['applications']:
            if app.get('architecture') == '${{ matrix.architecture }}' and app.get('conversion_status') == 'completed':
                converted += 1
        
        print(converted)
        ")
        
        echo "converted_count=$converted_count" >> $GITHUB_OUTPUT
        
        # Check if we have any meaningful changes in website directory
        if [ -n "$(git status --porcelain website/)" ]; then
          echo "changes_made=true" >> $GITHUB_OUTPUT
        else
          echo "changes_made=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Clean up temporary files
      if: steps.parse_apps.outputs.proceed == 'true'
      run: |
        cd scripts
        # Remove any log files from scripts directory (no other temp files created now)
        rm -f *.log
    
    - name: Commit conversion results
      if: steps.check_results.outputs.changes_made == 'true'
      run: |
        # Only add website-related changes, not script files
        git add website/
        
        # Pull latest changes to avoid conflicts
        git pull --rebase origin main
        
        git commit -m "Convert: ${{ steps.check_results.outputs.converted_count }} apps for ${{ matrix.architecture }} - $(date -u '+%Y-%m-%d %H:%M UTC')"
        git push
    
    - name: Upload conversion logs
      if: always() && steps.filter_apps.outputs.has_apps == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: conversion-logs-${{ matrix.architecture }}-${{ github.run_number }}
        path: scripts/*.log
        retention-days: 7
    
    - name: Create conversion summary
      if: always()
      run: |
        echo "## ðŸ”„ AppBinHub Conversion Summary (${{ matrix.architecture }})" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "- **Architecture:** ${{ matrix.architecture }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Apps for this arch:** ${{ steps.filter_apps.outputs.has_apps }}" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.filter_apps.outputs.has_apps }}" == "true" ]; then
          echo "- **Apps converted:** ${{ steps.check_results.outputs.converted_count || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Changes made:** ${{ steps.check_results.outputs.changes_made || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”§ Tool Status" >> $GITHUB_STEP_SUMMARY
          echo "- **unsquashfs:** $(unsquashfs --help 2>&1 | head -1 || echo 'not available')" >> $GITHUB_STEP_SUMMARY
          echo "- **dpkg-deb:** $(dpkg-deb --version 2>&1 | head -1 || echo 'not available')" >> $GITHUB_STEP_SUMMARY
          echo "- **rpmbuild:** $(rpmbuild --version 2>&1 | head -1 || echo 'not available')" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.parse_apps.outputs.apps_to_convert }}" != "[]" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“‹ Apps Processed" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            echo '${{ steps.parse_apps.outputs.apps_to_convert }}' | jq . >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "- **Status:** â¸ï¸ No apps for this architecture" >> $GITHUB_STEP_SUMMARY
        fi

