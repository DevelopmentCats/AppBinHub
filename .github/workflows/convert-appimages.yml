name: AppImage Conversion

on:
  workflow_dispatch:
    inputs:
      target_architecture:
        description: 'Target architecture for conversion'
        required: true
        type: choice
        options:
          - x86_64
          - aarch64
          - armv7l
          - i386
      apps_to_convert:
        description: 'JSON array of apps to convert'
        required: true
        type: string

# Prevent multiple conversion runs for the same architecture
concurrency:
  group: convert-${{ github.event.inputs.target_architecture }}
  cancel-in-progress: false

jobs:
  convert:
    runs-on: ubuntu-latest  # Use ubuntu-latest for all architectures with cross-compilation support
    
    permissions:
      contents: write
      pages: write
      id-token: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install Python dependencies
      run: |
        cd scripts
        pip install -r requirements.txt
    
    - name: Install system dependencies for conversion
      run: |
        sudo apt-get update
        
        # Install squashfs-tools for AppImage extraction (provides unsquashfs)
        sudo apt-get install -y squashfs-tools
        
        # Install dpkg-dev for creating .deb packages
        sudo apt-get install -y dpkg-dev
        
        # Install rpm for creating .rpm packages
        sudo apt-get install -y rpm
        
        # Install file utilities
        sudo apt-get install -y file binutils
        
        # Verify installations
        echo "Checking tool availability:"
        echo "âœ“ unsquashfs: $(unsquashfs --help 2>&1 | head -1 || echo 'version check failed but tool may be available')"
        echo "âœ“ dpkg-deb: $(dpkg-deb --version | head -1)"
        if command -v rpmbuild &> /dev/null; then
          echo "âœ“ rpmbuild: $(rpmbuild --version | head -1)"
        else
          echo "âœ— rpmbuild: not available (but rpm is installed for basic functionality)"
        fi
        
        # Ensure unsquashfs is in PATH and executable
        which unsquashfs
        ls -la $(which unsquashfs)
    
    - name: Set up QEMU for cross-architecture (if needed)
      if: github.event.inputs.target_architecture != 'x86_64'
      uses: docker/setup-qemu-action@v3
      with:
        platforms: linux/arm64,linux/arm/v7,linux/386
    
    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action Bot (${{ github.event.inputs.target_architecture }})"
    
    - name: Parse apps to convert
      id: parse_apps
      run: |
        apps='${{ github.event.inputs.apps_to_convert }}'
        echo "Apps to convert for ${{ github.event.inputs.target_architecture }}:"
        echo "$apps" | jq .
        
        # Count apps
        app_count=$(echo "$apps" | jq '. | length')
        echo "app_count=$app_count" >> $GITHUB_OUTPUT
        
        if [ "$app_count" -eq 0 ]; then
          echo "No apps to convert for this architecture"
          echo "has_apps=false" >> $GITHUB_OUTPUT
        else
          echo "has_apps=true" >> $GITHUB_OUTPUT
        fi
    
    - name: Filter applications by architecture
      if: steps.parse_apps.outputs.has_apps == 'true'
      id: filter_apps
      run: |
        cd scripts
        
        # Create a script to update conversion status for specific apps
        python3 -c "
        import json
        import sys
        
        # Parse input apps
        input_apps = json.loads('${{ github.event.inputs.apps_to_convert }}')
        target_arch = '${{ github.event.inputs.target_architecture }}'
        
        # Load current applications data
        with open('../website/data/applications.json', 'r') as f:
            data = json.load(f)
        
        # Filter apps for this architecture and mark them for conversion
        apps_for_conversion = []
        for app in data['applications']:
            for input_app in input_apps:
                if app['id'] == input_app['id'] and app.get('architecture') == target_arch:
                    apps_for_conversion.append(app['id'])
                    break
        
        print(f'Apps to convert: {apps_for_conversion}')
        
        # Save list for the converter
        with open('apps_to_convert.txt', 'w') as f:
            for app_id in apps_for_conversion:
                f.write(app_id + '\n')
        
        print(f'Found {len(apps_for_conversion)} apps for {target_arch}')
        "
        
        # Check if we have any apps
        if [ -f apps_to_convert.txt ] && [ -s apps_to_convert.txt ]; then
          echo "Apps to convert:"
          cat apps_to_convert.txt
          echo "proceed=true" >> $GITHUB_OUTPUT
        else
          echo "No apps found for conversion"
          echo "proceed=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Run architecture-specific conversion
      if: steps.filter_apps.outputs.proceed == 'true'
      run: |
        cd scripts
        
        # Create a modified converter that only processes specific apps
        python3 -c "
        import sys
        sys.path.append('.')
        from converter import ModernAppImageConverter
        import json
        
        # Read apps to convert
        with open('apps_to_convert.txt', 'r') as f:
            apps_to_convert = [line.strip() for line in f if line.strip()]
        
        print(f'Starting conversion for {len(apps_to_convert)} apps on ${{ github.event.inputs.target_architecture }}')
        
        # Initialize converter
        converter = ModernAppImageConverter()
        
        # Filter to only convert specified apps
        original_apps = converter.data['applications']
        converter.data['applications'] = [
            app for app in original_apps 
            if app['id'] in apps_to_convert and app.get('conversion_status') == 'pending'
        ]
        
        print(f'Filtered to {len(converter.data[\"applications\"])} pending apps')
        
        # Run conversion
        converter.convert_pending_applications()
        
        # Merge results back
        app_dict = {app['id']: app for app in converter.data['applications']}
        for i, app in enumerate(original_apps):
            if app['id'] in app_dict:
                original_apps[i] = app_dict[app['id']]
        
        converter.data['applications'] = original_apps
        converter.save_application_data()
        "
      continue-on-error: true
    
    - name: Check conversion results
      id: check_results
      run: |
        cd scripts
        
        # Check how many apps were successfully converted
        converted_count=$(python3 -c "
        import json
        with open('../website/data/applications.json', 'r') as f:
            data = json.load(f)
        
        converted = 0
        for app in data['applications']:
            if app.get('architecture') == '${{ github.event.inputs.target_architecture }}' and app.get('conversion_status') == 'completed':
                converted += 1
        
        print(converted)
        ")
        
        echo "converted_count=$converted_count" >> $GITHUB_OUTPUT
        
        # Check if we have any meaningful changes
        if [ -n "$(git status --porcelain)" ]; then
          echo "changes_made=true" >> $GITHUB_OUTPUT
        else
          echo "changes_made=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Commit conversion results
      if: steps.check_results.outputs.changes_made == 'true'
      run: |
        git add .
        git commit -m "Convert: ${{ steps.check_results.outputs.converted_count }} apps for ${{ github.event.inputs.target_architecture }} - $(date -u '+%Y-%m-%d %H:%M UTC')"
        git push
    
    - name: Deploy to GitHub Pages (if changes made)
      if: steps.check_results.outputs.changes_made == 'true'
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./website
        force_orphan: true
        enable_jekyll: false
        cname: false
    
    - name: Upload conversion logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: conversion-logs-${{ github.event.inputs.target_architecture }}-${{ github.run_number }}
        path: |
          scripts/*.log
          scripts/apps_to_convert.txt
        retention-days: 7
    
    - name: Create conversion summary
      if: always()
      run: |
        echo "## ðŸ”„ AppBinHub Conversion Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "- **Architecture:** ${{ github.event.inputs.target_architecture }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Apps requested:** ${{ steps.parse_apps.outputs.app_count }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Apps converted:** ${{ steps.check_results.outputs.converted_count }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes made:** ${{ steps.check_results.outputs.changes_made }}" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”§ Tool Status" >> $GITHUB_STEP_SUMMARY
        echo "- **unsquashfs:** $(unsquashfs --help 2>&1 | head -1 || echo 'not available')" >> $GITHUB_STEP_SUMMARY
        echo "- **dpkg-deb:** $(dpkg-deb --version 2>&1 | head -1 || echo 'not available')" >> $GITHUB_STEP_SUMMARY
        echo "- **rpmbuild:** $(rpmbuild --version 2>&1 | head -1 || echo 'not available')" >> $GITHUB_STEP_SUMMARY
        
        if [ -f scripts/apps_to_convert.txt ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Apps Processed" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat scripts/apps_to_convert.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi 